###############################################################################
#
# IAR ANSI C/C++ Compiler V9.40.2.374/W64 for ARM         16/Oct/2023  21:49:52
# Copyright 1999-2023 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =  D:\team2_week7\user\main.c
#    Command line      =
#        -f D:\team2_week7\Debug\Obj\user_8514941877209965082.dir\main.o.rsp
#        (D:\team2_week7\user\main.c -D USE_STDPERIPH_DRIVER -D STM32F10X_CL
#        -lC D:\team2_week7\Debug\List\user_8514941877209965082.dir -o
#        D:\team2_week7\Debug\Obj\user_8514941877209965082.dir --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files\IAR Systems\Embedded Workbench
#        9.2\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\team2_week7\libraries\CMSIS\DeviceSupport\ -I
#        D:\team2_week7\libraries\CMSIS\DeviceSupport\Startup\ -I
#        D:\team2_week7\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\ -I
#        D:\team2_week7\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\ -I
#        D:\team2_week7\user\ -I D:\team2_week7\user\inc\ -Ol -I "C:\Program
#        Files\IAR Systems\Embedded Workbench 9.2\arm\CMSIS\Core\Include\\")
#        --dependencies=n
#        D:\team2_week7\Debug\Obj\user_8514941877209965082.dir\main.o.iar_deps
#    Locale            =  C
#    List file         =
#        D:\team2_week7\Debug\List\user_8514941877209965082.dir\main.lst
#    Object file       =
#        D:\team2_week7\Debug\Obj\user_8514941877209965082.dir\main.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

D:\team2_week7\user\main.c
      1          
      2          #include "stm32f10x.h"

   \                                 In section .text, align 4, keep-with-next
   \   static __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB249             SXTB     R1,R1
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \        0xE   0x408A             LSLS     R2,R2,R1
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable11
   \       0x14   0xB240             SXTB     R0,R0
   \       0x16   0x0940             LSRS     R0,R0,#+5
   \       0x18   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x1C   0x4770             BX       LR
      3          #include "stm32f10x_exti.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_usart.h"
      6          #include "stm32f10x_rcc.h"
      7          
      8          #include "misc.h"
      9          #include <stdbool.h>
     10          
     11          /* function prototype */
     12          void RCC_Configure(void);
     13          void GPIO_Configure(void);
     14          void EXTI_Configure(void);
     15          void USART1_Init(void);
     16          void NVIC_Configure(void);
     17          
     18          void EXTI15_10_IRQHandler(void);
     19          void onLed(int i);
     20          void Delay(void);
     21          
     22          void sendDataUART1(uint16_t data);
     23          
     24          void go_advan(void);
     25          void go_back(void);
     26          
     27          

   \                                 In section .bss, align 4
     28          int flag = 0;
   \                     flag:
   \        0x0                      DS8 4

   \                                 In section .data, align 1
     29          bool advan_back = true;
   \                     advan_back:
   \        0x0   0x01               DC8 1
     30          
     31          //---------------------------------------------------------------------------------------------------
     32          

   \                                 In section .text, align 2, keep-with-next
     33          void RCC_Configure(void)
     34          {
   \                     RCC_Configure: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     35             // TODO: Enable the APB2 peripheral clock using the function 'RCC_APB2PeriphClockCmd'
     36             
     37              /* UART TX/RX port clock enable */
     38              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x2004             MOVS     R0,#+4
   \        0x6   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     39             /* Button S1, S2, S3 port clock enable */
     40              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x2008             MOVS     R0,#+8
   \        0xE   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     41              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0x2010             MOVS     R0,#+16
   \       0x16   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     42             
     43             /* LED port clock enable */
     44              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x2020             MOVS     R0,#+32
   \       0x1E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     45             
     46             /* USART1 clock enable */
     47             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0xF44F 0x4080      MOV      R0,#+16384
   \       0x28   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     48                
     49             /* Alternate Function IO clock enable */
     50             RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     51          }
   \       0x34   0xBD01             POP      {R0,PC}
     52          

   \                                 In section .text, align 2, keep-with-next
     53          void GPIO_Configure(void)
     54          {
   \                     GPIO_Configure: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
     55              GPIO_InitTypeDef GPIO_InitStructure;
     56          
     57             // TODO: Initialize the GPIO pins using the structure 'GPIO_InitTypeDef' and the function 'GPIO_Init'
     58             
     59              /* Button S1, S2, S3 pin setting */
     60              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_13;     // KEY1, KEY3
   \        0x2   0xF242 0x0010      MOVW     R0,#+8208
   \        0x6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     61              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \        0xA   0x2028             MOVS     R0,#+40
   \        0xC   0xF88D 0x0003      STRB     R0,[SP, #+3]
     62              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \       0x16   0x.... 0x....      BL       GPIO_Init
     63          
     64              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;                  // KEY2
   \       0x1A   0xF44F 0x6480      MOV      R4,#+1024
   \       0x1E   0xF8AD 0x4000      STRH     R4,[SP, #+0]
     65              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \       0x22   0x2028             MOVS     R0,#+40
   \       0x24   0xF88D 0x0003      STRB     R0,[SP, #+3]
     66              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \       0x28   0x4669             MOV      R1,SP
   \       0x2A   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \       0x2E   0x.... 0x....      BL       GPIO_Init
     67          
     68              
     69              
     70              /* LED pin setting*/
     71              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7;
   \       0x32   0x209C             MOVS     R0,#+156
   \       0x34   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     72              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0xF88D 0x0002      STRB     R0,[SP, #+2]
     73              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \       0x3E   0x2010             MOVS     R0,#+16
   \       0x40   0xF88D 0x0003      STRB     R0,[SP, #+3]
     74              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0x4A   0x.... 0x....      BL       GPIO_Init
     75             
     76              /* UART pin setting */
     77              //TX
     78              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \       0x4E   0xF44F 0x7000      MOV      R0,#+512
   \       0x52   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     79              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \       0x56   0x2018             MOVS     R0,#+24
   \       0x58   0xF88D 0x0003      STRB     R0,[SP, #+3]
     80              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x5C   0x2003             MOVS     R0,#+3
   \       0x5E   0xF88D 0x0002      STRB     R0,[SP, #+2]
     81              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x62   0x.... 0x....      LDR.W    R5,??DataTable11_4
   \       0x66   0x4669             MOV      R1,SP
   \       0x68   0x0028             MOVS     R0,R5
   \       0x6A   0x.... 0x....      BL       GPIO_Init
     82              
     83             //RX
     84              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \       0x6E   0xF8AD 0x4000      STRH     R4,[SP, #+0]
     85              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \       0x72   0x2028             MOVS     R0,#+40
   \       0x74   0xF88D 0x0003      STRB     R0,[SP, #+3]
     86              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \       0x78   0x2003             MOVS     R0,#+3
   \       0x7A   0xF88D 0x0002      STRB     R0,[SP, #+2]
     87              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x7E   0x4669             MOV      R1,SP
   \       0x80   0x0028             MOVS     R0,R5
   \       0x82   0x.... 0x....      BL       GPIO_Init
     88          }
   \       0x86   0xBD31             POP      {R0,R4,R5,PC}
     89          

   \                                 In section .text, align 2, keep-with-next
     90          void EXTI_Configure(void)
     91          {
   \                     EXTI_Configure: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
     92              EXTI_InitTypeDef EXTI_InitStructure;
     93          
     94             // TODO: Select the GPIO pin (Joystick, button) used as EXTI Line using function 'GPIO_EXTILineConfig'
     95             // TODO: Initialize the EXTI using the structure 'EXTI_InitTypeDef' and the function 'EXTI_Init'
     96             
     97              /* Button S1 */
     98             GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource4);
   \        0x2   0x2104             MOVS     R1,#+4
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x.... 0x....      BL       GPIO_EXTILineConfig
     99              EXTI_InitStructure.EXTI_Line = EXTI_Line4;
   \        0xA   0x2010             MOVS     R0,#+16
   \        0xC   0x9000             STR      R0,[SP, #+0]
    100              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0xF88D 0x0004      STRB     R0,[SP, #+4]
    101              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \       0x14   0x200C             MOVS     R0,#+12
   \       0x16   0xF88D 0x0005      STRB     R0,[SP, #+5]
    102              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    103              EXTI_Init(&EXTI_InitStructure);
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x.... 0x....      BL       EXTI_Init
    104          
    105              /* Button S2 */
    106              GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource10);
   \       0x26   0x210A             MOVS     R1,#+10
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0x.... 0x....      BL       GPIO_EXTILineConfig
    107              EXTI_InitStructure.EXTI_Line = EXTI_Line10;
   \       0x2E   0xF44F 0x6080      MOV      R0,#+1024
   \       0x32   0x9000             STR      R0,[SP, #+0]
    108              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF88D 0x0004      STRB     R0,[SP, #+4]
    109              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \       0x3A   0x200C             MOVS     R0,#+12
   \       0x3C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    110              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xF88D 0x0006      STRB     R0,[SP, #+6]
    111              EXTI_Init(&EXTI_InitStructure);
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x.... 0x....      BL       EXTI_Init
    112             
    113             /* Button S3 */
    114              GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
   \       0x4C   0x210D             MOVS     R1,#+13
   \       0x4E   0x2002             MOVS     R0,#+2
   \       0x50   0x.... 0x....      BL       GPIO_EXTILineConfig
    115              EXTI_InitStructure.EXTI_Line = EXTI_Line13;
   \       0x54   0xF44F 0x5000      MOV      R0,#+8192
   \       0x58   0x9000             STR      R0,[SP, #+0]
    116              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    117              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \       0x60   0x200C             MOVS     R0,#+12
   \       0x62   0xF88D 0x0005      STRB     R0,[SP, #+5]
    118              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0xF88D 0x0006      STRB     R0,[SP, #+6]
    119              EXTI_Init(&EXTI_InitStructure);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x.... 0x....      BL       EXTI_Init
    120          
    121             // NOTE: do not select the UART GPIO pin used as EXTI Line here
    122          }
   \       0x72   0xBD07             POP      {R0-R2,PC}
    123          

   \                                 In section .text, align 2, keep-with-next
    124          void USART1_Init(void)
    125          {
   \                     USART1_Init: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
    126             USART_InitTypeDef USART1_InitStructure;
    127          
    128             // Enable the USART1 peripheral
    129             USART_Cmd(USART1, ENABLE);
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable11_5
   \        0x6   0x2101             MOVS     R1,#+1
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       USART_Cmd
    130             
    131             // TODO: Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    132             USART1_InitStructure.USART_BaudRate = 9600;
   \        0xE   0xF44F 0x5016      MOV      R0,#+9600
   \       0x12   0x9000             STR      R0,[SP, #+0]
    133              USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    134              USART1_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \       0x1A   0x200C             MOVS     R0,#+12
   \       0x1C   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    135              USART1_InitStructure.USART_Parity = USART_Parity_No;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    136              USART1_InitStructure.USART_StopBits = USART_StopBits_1;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    137              USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    138              USART_Init(USART1, &USART1_InitStructure);
   \       0x32   0x4669             MOV      R1,SP
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       USART_Init
    139             
    140             // TODO: Enable the USART1 RX interrupts using the function 'USART_ITConfig' and the argument value 'Receive Data register not empty interrupt'
    141             USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   \       0x3A   0x2201             MOVS     R2,#+1
   \       0x3C   0xF240 0x5125      MOVW     R1,#+1317
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x.... 0x....      BL       USART_ITConfig
    142          }
   \       0x46   0xBD1F             POP      {R0-R4,PC}
    143          

   \                                 In section .text, align 2, keep-with-next
    144          void NVIC_Configure(void) {
   \                     NVIC_Configure: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    145          
    146              NVIC_InitTypeDef NVIC_InitStructure;
    147              
    148              // TODO: fill the arg you want
    149              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \        0x2   0xF44F 0x60A0      MOV      R0,#+1280
   \        0x6   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    150          
    151          
    152             // TODO: Initialize the NVIC using the structure 'NVIC_InitTypeDef' and the function 'NVIC_Init'
    153          
    154          
    155              // Button S1
    156             NVIC_EnableIRQ(EXTI4_IRQn);
   \        0xA   0x200A             MOVS     R0,#+10
   \        0xC   0x.... 0x....      BL       __NVIC_EnableIRQ
    157              NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
   \       0x10   0x200A             MOVS     R0,#+10
   \       0x12   0xF88D 0x0000      STRB     R0,[SP, #+0]
    158              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00; // TODO
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF88D 0x0001      STRB     R0,[SP, #+1]
    159              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00; // TODO
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    160              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xF88D 0x0003      STRB     R0,[SP, #+3]
    161              NVIC_Init(&NVIC_InitStructure);
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x.... 0x....      BL       NVIC_Init
    162          
    163          
    164              // Button S2, S3
    165              NVIC_EnableIRQ(EXTI15_10_IRQn);
   \       0x2E   0x2028             MOVS     R0,#+40
   \       0x30   0x.... 0x....      BL       __NVIC_EnableIRQ
    166              NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \       0x34   0x2028             MOVS     R0,#+40
   \       0x36   0xF88D 0x0000      STRB     R0,[SP, #+0]
    167              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00; // TODO
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    168              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00; // TODO
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xF88D 0x0002      STRB     R0,[SP, #+2]
    169              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xF88D 0x0003      STRB     R0,[SP, #+3]
    170              NVIC_Init(&NVIC_InitStructure);
   \       0x4C   0x4668             MOV      R0,SP
   \       0x4E   0x.... 0x....      BL       NVIC_Init
    171          
    172              // UART1
    173             // 'NVIC_EnableIRQ' is only required for USART setting
    174              NVIC_EnableIRQ(USART1_IRQn);
   \       0x52   0x2025             MOVS     R0,#+37
   \       0x54   0x.... 0x....      BL       __NVIC_EnableIRQ
    175              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \       0x58   0x2025             MOVS     R0,#+37
   \       0x5A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    176              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;// TODO
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF88D 0x0001      STRB     R0,[SP, #+1]
    177              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00; // TODO
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF88D 0x0002      STRB     R0,[SP, #+2]
    178              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    179              NVIC_Init(&NVIC_InitStructure);
   \       0x70   0x4668             MOV      R0,SP
   \       0x72   0x.... 0x....      BL       NVIC_Init
    180          }
   \       0x76   0xBD01             POP      {R0,PC}
    181          

   \                                 In section .text, align 2, keep-with-next
    182          void USART1_IRQHandler() {
   \                     USART1_IRQHandler: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    183             uint16_t word;
    184              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \        0x2   0x.... 0x....      LDR.W    R4,??DataTable11_5
   \        0x6   0xF240 0x5525      MOVW     R5,#+1317
   \        0xA   0x0029             MOVS     R1,R5
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0x.... 0x....      BL       USART_GetITStatus
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD01B             BEQ.N    ??USART1_IRQHandler_0
    185                 // the most recent received data by the USART1 peripheral
    186                  word = USART_ReceiveData(USART1);
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       USART_ReceiveData
    187          
    188                  // TODO implement
    189                   if(word =='a'){
   \       0x1C   0x0001             MOVS     R1,R0
   \       0x1E   0xB289             UXTH     R1,R1
   \       0x20   0x2961             CMP      R1,#+97
   \       0x22   0xD104             BNE.N    ??USART1_IRQHandler_1
    190                     advan_back=true;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \       0x2A   0x7008             STRB     R0,[R1, #+0]
   \       0x2C   0xE00B             B.N      ??USART1_IRQHandler_2
    191                   } else if(word == 'b'){
   \                     ??USART1_IRQHandler_1: (+1)
   \       0x2E   0xB280             UXTH     R0,R0
   \       0x30   0x2862             CMP      R0,#+98
   \       0x32   0xD108             BNE.N    ??USART1_IRQHandler_2
    192                     onLed(flag);
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x.... 0x....      BL       onLed
    193                      advan_back=false;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \       0x44   0x7008             STRB     R0,[R1, #+0]
    194                   }
    195          
    196                  // clear 'Read data register not empty' flag
    197                 USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \                     ??USART1_IRQHandler_2: (+1)
   \       0x46   0x0029             MOVS     R1,R5
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       USART_ClearITPendingBit
    198              }
    199          }
   \                     ??USART1_IRQHandler_0: (+1)
   \       0x4E   0xBD31             POP      {R0,R4,R5,PC}
    200          

   \                                 In section .text, align 2, keep-with-next
    201          void EXTI15_10_IRQHandler(void) { // when the button is pressed
   \                     EXTI15_10_IRQHandler: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
    202              char team[] = "TEAM02\r\n";
   \        0x2   0x4668             MOV      R0,SP
   \        0x4   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \        0x8   0xE891 0x001C      LDM      R1,{R2-R4}
   \        0xC   0xE880 0x001C      STM      R0,{R2-R4}
    203              if (EXTI_GetITStatus(EXTI_Line10) != RESET) {
   \       0x10   0xF44F 0x6080      MOV      R0,#+1024
   \       0x14   0x.... 0x....      BL       EXTI_GetITStatus
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD00D             BEQ.N    ??EXTI15_10_IRQHandler_0
    204                if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_10) == Bit_RESET) {
   \       0x1C   0xF44F 0x6180      MOV      R1,#+1024
   \       0x20   0x....             LDR.N    R0,??DataTable11_2
   \       0x22   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD102             BNE.N    ??EXTI15_10_IRQHandler_1
    205                     advan_back=false;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x....             LDR.N    R1,??DataTable11_6
   \       0x2E   0x7008             STRB     R0,[R1, #+0]
    206                }
    207                EXTI_ClearITPendingBit(EXTI_Line10);
   \                     ??EXTI15_10_IRQHandler_1: (+1)
   \       0x30   0xF44F 0x6080      MOV      R0,#+1024
   \       0x34   0x.... 0x....      BL       EXTI_ClearITPendingBit
    208             }
    209              if (EXTI_GetITStatus(EXTI_Line13) != RESET) {
   \                     ??EXTI15_10_IRQHandler_0: (+1)
   \       0x38   0xF44F 0x5000      MOV      R0,#+8192
   \       0x3C   0x.... 0x....      BL       EXTI_GetITStatus
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD014             BEQ.N    ??EXTI15_10_IRQHandler_2
    210                if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == Bit_RESET) {
   \       0x44   0xF44F 0x5100      MOV      R1,#+8192
   \       0x48   0x....             LDR.N    R0,??DataTable11_1
   \       0x4A   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD109             BNE.N    ??EXTI15_10_IRQHandler_3
    211                  for(int i=0; i<8; i++){
   \       0x52   0x2400             MOVS     R4,#+0
   \       0x54   0xE005             B.N      ??EXTI15_10_IRQHandler_4
    212                     sendDataUART1(team[i]);
   \                     ??EXTI15_10_IRQHandler_5: (+1)
   \       0x56   0x4668             MOV      R0,SP
   \       0x58   0x5D00             LDRB     R0,[R0, R4]
   \       0x5A   0xB280             UXTH     R0,R0
   \       0x5C   0x.... 0x....      BL       sendDataUART1
    213                  }
   \       0x60   0x1C64             ADDS     R4,R4,#+1
   \                     ??EXTI15_10_IRQHandler_4: (+1)
   \       0x62   0x2C08             CMP      R4,#+8
   \       0x64   0xDBF7             BLT.N    ??EXTI15_10_IRQHandler_5
    214                }
    215                  EXTI_ClearITPendingBit(EXTI_Line13);
   \                     ??EXTI15_10_IRQHandler_3: (+1)
   \       0x66   0xF44F 0x5000      MOV      R0,#+8192
   \       0x6A   0x.... 0x....      BL       EXTI_ClearITPendingBit
    216             }
    217          }
   \                     ??EXTI15_10_IRQHandler_2: (+1)
   \       0x6E   0xBD1F             POP      {R0-R4,PC}

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x54 0x45          DC8 "TEAM02\015\012"
   \              0x41 0x4D    
   \              0x30 0x32    
   \              0x0D 0x0A    
   \              0x00
   \        0x9                      DS8 3
    218          
    219          
    220          
    221          // TODO: Create Joystick interrupt handler functions
    222          

   \                                 In section .text, align 2, keep-with-next
    223          void EXTI4_IRQHandler(void) { // when the button is pressed
   \                     EXTI4_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    224          
    225              if (EXTI_GetITStatus(EXTI_Line4) != RESET) {
   \        0x2   0x2010             MOVS     R0,#+16
   \        0x4   0x.... 0x....      BL       EXTI_GetITStatus
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD00B             BEQ.N    ??EXTI4_IRQHandler_0
    226                if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_4) == Bit_RESET) {
   \        0xC   0x2110             MOVS     R1,#+16
   \        0xE   0x....             LDR.N    R0,??DataTable11_1
   \       0x10   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD102             BNE.N    ??EXTI4_IRQHandler_1
    227                      advan_back=true;
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x....             LDR.N    R1,??DataTable11_6
   \       0x1C   0x7008             STRB     R0,[R1, #+0]
    228                }
    229                EXTI_ClearITPendingBit(EXTI_Line4);
   \                     ??EXTI4_IRQHandler_1: (+1)
   \       0x1E   0x2010             MOVS     R0,#+16
   \       0x20   0x.... 0x....      BL       EXTI_ClearITPendingBit
    230             }
    231          }
   \                     ??EXTI4_IRQHandler_0: (+1)
   \       0x24   0xBD01             POP      {R0,PC}
    232          
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void Delay(void) {
    235             int i;
    236          
    237             for (i = 0; i < 1000000; i++) {}
   \                     Delay: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0xE000             B.N      ??Delay_0
   \                     ??Delay_1: (+1)
   \        0x4   0x1C40             ADDS     R0,R0,#+1
   \                     ??Delay_0: (+1)
   \        0x6   0x....             LDR.N    R1,??DataTable11_9
   \        0x8   0x4288             CMP      R0,R1
   \        0xA   0xDBFB             BLT.N    ??Delay_1
    238          }
   \        0xC   0x4770             BX       LR
    239          

   \                                 In section .text, align 2, keep-with-next
    240          void sendDataUART1(uint16_t data) {
   \                     sendDataUART1: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0001             MOVS     R1,R0
    241             /* Wait till TC is set */
    242              USART_SendData(USART1, data);
   \        0x4   0x....             LDR.N    R4,??DataTable11_5
   \        0x6   0xB289             UXTH     R1,R1
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x.... 0x....      BL       USART_SendData
    243             while ((USART1->SR & USART_SR_TC) == 0);
   \                     ??sendDataUART1_0: (+1)
   \        0xE   0x8820             LDRH     R0,[R4, #+0]
   \       0x10   0x0640             LSLS     R0,R0,#+25
   \       0x12   0xD5FC             BPL.N    ??sendDataUART1_0
    244                
    245          }
   \       0x14   0xBD10             POP      {R4,PC}
    246          

   \                                 In section .text, align 2, keep-with-next
    247          void go_advan(void){
   \                     go_advan: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    248              
    249          
    250              if(flag == 0){
   \        0x2   0x....             LDR.N    R4,??DataTable11_7
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD118             BNE.N    ??go_advan_0
    251              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \        0xA   0x....             LDR.N    R5,??DataTable11_3
   \        0xC   0x2104             MOVS     R1,#+4
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       GPIO_SetBits
    252              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \       0x14   0x2108             MOVS     R1,#+8
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x.... 0x....      BL       GPIO_SetBits
    253              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \       0x1C   0x2110             MOVS     R1,#+16
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0x.... 0x....      BL       GPIO_SetBits
    254              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \       0x24   0x2180             MOVS     R1,#+128
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       GPIO_SetBits
    255              
    256              GPIO_ResetBits(GPIOD, GPIO_Pin_2);
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0x.... 0x....      BL       GPIO_ResetBits
    257              Delay();
   \       0x34   0x.... 0x....      BL       Delay
    258              flag = 1;
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0x6020             STR      R0,[R4, #+0]
    259              }
    260              if(flag == 1) {      
   \                     ??go_advan_0: (+1)
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD118             BNE.N    ??go_advan_1
    261              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \       0x42   0x....             LDR.N    R5,??DataTable11_3
   \       0x44   0x2104             MOVS     R1,#+4
   \       0x46   0x0028             MOVS     R0,R5
   \       0x48   0x.... 0x....      BL       GPIO_SetBits
    262              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \       0x4C   0x2108             MOVS     R1,#+8
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0x.... 0x....      BL       GPIO_SetBits
    263              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \       0x54   0x2110             MOVS     R1,#+16
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0x.... 0x....      BL       GPIO_SetBits
    264              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \       0x5C   0x2180             MOVS     R1,#+128
   \       0x5E   0x0028             MOVS     R0,R5
   \       0x60   0x.... 0x....      BL       GPIO_SetBits
    265              
    266              GPIO_ResetBits(GPIOD, GPIO_Pin_3);
   \       0x64   0x2108             MOVS     R1,#+8
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0x.... 0x....      BL       GPIO_ResetBits
    267              flag=2;
   \       0x6C   0x2002             MOVS     R0,#+2
   \       0x6E   0x6020             STR      R0,[R4, #+0]
    268              Delay();
   \       0x70   0x.... 0x....      BL       Delay
    269              }
    270              if(flag == 2) {
   \                     ??go_advan_1: (+1)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x2802             CMP      R0,#+2
   \       0x78   0xD118             BNE.N    ??go_advan_2
    271              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \       0x7A   0x....             LDR.N    R5,??DataTable11_3
   \       0x7C   0x2104             MOVS     R1,#+4
   \       0x7E   0x0028             MOVS     R0,R5
   \       0x80   0x.... 0x....      BL       GPIO_SetBits
    272              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \       0x84   0x2108             MOVS     R1,#+8
   \       0x86   0x0028             MOVS     R0,R5
   \       0x88   0x.... 0x....      BL       GPIO_SetBits
    273              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \       0x8C   0x2110             MOVS     R1,#+16
   \       0x8E   0x0028             MOVS     R0,R5
   \       0x90   0x.... 0x....      BL       GPIO_SetBits
    274              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \       0x94   0x2180             MOVS     R1,#+128
   \       0x96   0x0028             MOVS     R0,R5
   \       0x98   0x.... 0x....      BL       GPIO_SetBits
    275              
    276              GPIO_ResetBits(GPIOD, GPIO_Pin_4);
   \       0x9C   0x2110             MOVS     R1,#+16
   \       0x9E   0x0028             MOVS     R0,R5
   \       0xA0   0x.... 0x....      BL       GPIO_ResetBits
    277              flag=3;
   \       0xA4   0x2003             MOVS     R0,#+3
   \       0xA6   0x6020             STR      R0,[R4, #+0]
    278              Delay();
   \       0xA8   0x.... 0x....      BL       Delay
    279              }
    280              if(flag == 3){
   \                     ??go_advan_2: (+1)
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x2803             CMP      R0,#+3
   \       0xB0   0xD118             BNE.N    ??go_advan_3
    281              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \       0xB2   0x....             LDR.N    R5,??DataTable11_3
   \       0xB4   0x2104             MOVS     R1,#+4
   \       0xB6   0x0028             MOVS     R0,R5
   \       0xB8   0x.... 0x....      BL       GPIO_SetBits
    282              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \       0xBC   0x2108             MOVS     R1,#+8
   \       0xBE   0x0028             MOVS     R0,R5
   \       0xC0   0x.... 0x....      BL       GPIO_SetBits
    283              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \       0xC4   0x2110             MOVS     R1,#+16
   \       0xC6   0x0028             MOVS     R0,R5
   \       0xC8   0x.... 0x....      BL       GPIO_SetBits
    284              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \       0xCC   0x2180             MOVS     R1,#+128
   \       0xCE   0x0028             MOVS     R0,R5
   \       0xD0   0x.... 0x....      BL       GPIO_SetBits
    285              
    286              GPIO_ResetBits(GPIOD, GPIO_Pin_7);
   \       0xD4   0x2180             MOVS     R1,#+128
   \       0xD6   0x0028             MOVS     R0,R5
   \       0xD8   0x.... 0x....      BL       GPIO_ResetBits
    287              flag=0;
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0x6020             STR      R0,[R4, #+0]
    288              Delay();
   \       0xE0   0x.... 0x....      BL       Delay
    289              }
    290          }
   \                     ??go_advan_3: (+1)
   \       0xE4   0xBD31             POP      {R0,R4,R5,PC}
    291          

   \                                 In section .text, align 2, keep-with-next
    292          void go_back(void){
   \                     go_back: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    293              
    294          
    295              if(flag == 3){
   \        0x2   0x....             LDR.N    R4,??DataTable11_7
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x2803             CMP      R0,#+3
   \        0x8   0xD119             BNE.N    ??go_back_0
    296              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \        0xA   0x....             LDR.N    R5,??DataTable11_3
   \        0xC   0x2104             MOVS     R1,#+4
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       GPIO_SetBits
    297              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \       0x14   0x2108             MOVS     R1,#+8
   \       0x16   0x0028             MOVS     R0,R5
   \       0x18   0x.... 0x....      BL       GPIO_SetBits
    298              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \       0x1C   0x2110             MOVS     R1,#+16
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0x.... 0x....      BL       GPIO_SetBits
    299              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \       0x24   0x2180             MOVS     R1,#+128
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       GPIO_SetBits
    300              
    301              GPIO_ResetBits(GPIOD, GPIO_Pin_7);
   \       0x2C   0x2180             MOVS     R1,#+128
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0x.... 0x....      BL       GPIO_ResetBits
    302              flag =2;
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0x6020             STR      R0,[R4, #+0]
    303              Delay();
   \       0x38   0x.... 0x....      BL       Delay
   \       0x3C   0xE055             B.N      ??go_back_1
    304              }
    305              else if(flag == 2){
   \                     ??go_back_0: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x2802             CMP      R0,#+2
   \       0x42   0xD119             BNE.N    ??go_back_2
    306              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \       0x44   0x....             LDR.N    R5,??DataTable11_3
   \       0x46   0x2104             MOVS     R1,#+4
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0x.... 0x....      BL       GPIO_SetBits
    307              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \       0x4E   0x2108             MOVS     R1,#+8
   \       0x50   0x0028             MOVS     R0,R5
   \       0x52   0x.... 0x....      BL       GPIO_SetBits
    308              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \       0x56   0x2110             MOVS     R1,#+16
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0x.... 0x....      BL       GPIO_SetBits
    309              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \       0x5E   0x2180             MOVS     R1,#+128
   \       0x60   0x0028             MOVS     R0,R5
   \       0x62   0x.... 0x....      BL       GPIO_SetBits
    310              
    311              GPIO_ResetBits(GPIOD, GPIO_Pin_4);
   \       0x66   0x2110             MOVS     R1,#+16
   \       0x68   0x0028             MOVS     R0,R5
   \       0x6A   0x.... 0x....      BL       GPIO_ResetBits
    312              flag=1;
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0x6020             STR      R0,[R4, #+0]
    313              Delay();
   \       0x72   0x.... 0x....      BL       Delay
   \       0x76   0xE038             B.N      ??go_back_1
    314              }
    315              else if(flag == 1){
   \                     ??go_back_2: (+1)
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x2801             CMP      R0,#+1
   \       0x7C   0xD119             BNE.N    ??go_back_3
    316              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \       0x7E   0x....             LDR.N    R5,??DataTable11_3
   \       0x80   0x2104             MOVS     R1,#+4
   \       0x82   0x0028             MOVS     R0,R5
   \       0x84   0x.... 0x....      BL       GPIO_SetBits
    317              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \       0x88   0x2108             MOVS     R1,#+8
   \       0x8A   0x0028             MOVS     R0,R5
   \       0x8C   0x.... 0x....      BL       GPIO_SetBits
    318              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \       0x90   0x2110             MOVS     R1,#+16
   \       0x92   0x0028             MOVS     R0,R5
   \       0x94   0x.... 0x....      BL       GPIO_SetBits
    319              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \       0x98   0x2180             MOVS     R1,#+128
   \       0x9A   0x0028             MOVS     R0,R5
   \       0x9C   0x.... 0x....      BL       GPIO_SetBits
    320              
    321              GPIO_ResetBits(GPIOD, GPIO_Pin_3);
   \       0xA0   0x2108             MOVS     R1,#+8
   \       0xA2   0x0028             MOVS     R0,R5
   \       0xA4   0x.... 0x....      BL       GPIO_ResetBits
    322              flag=0;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x6020             STR      R0,[R4, #+0]
    323              Delay();
   \       0xAC   0x.... 0x....      BL       Delay
   \       0xB0   0xE01B             B.N      ??go_back_1
    324              }
    325              else if(flag == 0){
   \                     ??go_back_3: (+1)
   \       0xB2   0x6820             LDR      R0,[R4, #+0]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD118             BNE.N    ??go_back_1
    326              GPIO_SetBits(GPIOD, GPIO_Pin_2);
   \       0xB8   0x....             LDR.N    R5,??DataTable11_3
   \       0xBA   0x2104             MOVS     R1,#+4
   \       0xBC   0x0028             MOVS     R0,R5
   \       0xBE   0x.... 0x....      BL       GPIO_SetBits
    327              GPIO_SetBits(GPIOD, GPIO_Pin_3);
   \       0xC2   0x2108             MOVS     R1,#+8
   \       0xC4   0x0028             MOVS     R0,R5
   \       0xC6   0x.... 0x....      BL       GPIO_SetBits
    328              GPIO_SetBits(GPIOD, GPIO_Pin_4);
   \       0xCA   0x2110             MOVS     R1,#+16
   \       0xCC   0x0028             MOVS     R0,R5
   \       0xCE   0x.... 0x....      BL       GPIO_SetBits
    329              GPIO_SetBits(GPIOD, GPIO_Pin_7);
   \       0xD2   0x2180             MOVS     R1,#+128
   \       0xD4   0x0028             MOVS     R0,R5
   \       0xD6   0x.... 0x....      BL       GPIO_SetBits
    330              
    331              GPIO_ResetBits(GPIOD, GPIO_Pin_2);
   \       0xDA   0x2104             MOVS     R1,#+4
   \       0xDC   0x0028             MOVS     R0,R5
   \       0xDE   0x.... 0x....      BL       GPIO_ResetBits
    332              Delay();
   \       0xE2   0x.... 0x....      BL       Delay
    333              flag=3;
   \       0xE6   0x2003             MOVS     R0,#+3
   \       0xE8   0x6020             STR      R0,[R4, #+0]
    334              }    
    335          }
   \                     ??go_back_1: (+1)
   \       0xEA   0xBD31             POP      {R0,R4,R5,PC}
    336          

   \                                 In section .text, align 2, keep-with-next
    337          void onLed(int i){
   \                     onLed: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    338            
    339              GPIO_SetBits(GPIOD, GPIO_Pin_2);   
   \        0x4   0x....             LDR.N    R5,??DataTable11_3
   \        0x6   0x2104             MOVS     R1,#+4
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0x.... 0x....      BL       GPIO_SetBits
    340              GPIO_SetBits(GPIOD, GPIO_Pin_3);   
   \        0xE   0x2108             MOVS     R1,#+8
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       GPIO_SetBits
    341              GPIO_SetBits(GPIOD, GPIO_Pin_4);   
   \       0x16   0x2110             MOVS     R1,#+16
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       GPIO_SetBits
    342              GPIO_SetBits(GPIOD, GPIO_Pin_7);   
   \       0x1E   0x2180             MOVS     R1,#+128
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0x.... 0x....      BL       GPIO_SetBits
    343            switch(i){
   \       0x26   0x2C00             CMP      R4,#+0
   \       0x28   0xD005             BEQ.N    ??onLed_0
   \       0x2A   0x2C02             CMP      R4,#+2
   \       0x2C   0xD011             BEQ.N    ??onLed_1
   \       0x2E   0xD309             BCC.N    ??onLed_2
   \       0x30   0x2C03             CMP      R4,#+3
   \       0x32   0xD015             BEQ.N    ??onLed_3
   \       0x34   0xE01A             B.N      ??onLed_4
    344            case 0:
    345              GPIO_ResetBits(GPIOD, GPIO_Pin_2);
   \                     ??onLed_0: (+1)
   \       0x36   0x2104             MOVS     R1,#+4
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x.... 0x....      BL       GPIO_ResetBits
    346              
    347                 Delay();  
   \       0x3E   0x.... 0x....      BL       Delay
    348              break;
   \       0x42   0xE013             B.N      ??onLed_4
    349            case 1:
    350              GPIO_ResetBits(GPIOD, GPIO_Pin_3);
   \                     ??onLed_2: (+1)
   \       0x44   0x2108             MOVS     R1,#+8
   \       0x46   0x0028             MOVS     R0,R5
   \       0x48   0x.... 0x....      BL       GPIO_ResetBits
    351              
    352                 Delay();  
   \       0x4C   0x.... 0x....      BL       Delay
    353              break;
   \       0x50   0xE00C             B.N      ??onLed_4
    354            case 2:
    355              GPIO_ResetBits(GPIOD, GPIO_Pin_4);
   \                     ??onLed_1: (+1)
   \       0x52   0x2110             MOVS     R1,#+16
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0x.... 0x....      BL       GPIO_ResetBits
    356              
    357                 Delay();  
   \       0x5A   0x.... 0x....      BL       Delay
    358              break;
   \       0x5E   0xE005             B.N      ??onLed_4
    359            case 3:
    360              GPIO_ResetBits(GPIOD, GPIO_Pin_7);
   \                     ??onLed_3: (+1)
   \       0x60   0x2180             MOVS     R1,#+128
   \       0x62   0x0028             MOVS     R0,R5
   \       0x64   0x.... 0x....      BL       GPIO_ResetBits
    361              
    362                 Delay();  
   \       0x68   0x.... 0x....      BL       Delay
    363              break;
    364            }
    365          }
   \                     ??onLed_4: (+1)
   \       0x6C   0xBD31             POP      {R0,R4,R5,PC}
    366          

   \                                 In section .text, align 2, keep-with-next
    367          int main(void){
   \                     main: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    368          
    369              SystemInit();
   \        0x2   0x.... 0x....      BL       SystemInit
    370          
    371              RCC_Configure();
   \        0x6   0x.... 0x....      BL       RCC_Configure
    372          
    373              GPIO_Configure();
   \        0xA   0x.... 0x....      BL       GPIO_Configure
    374          
    375              EXTI_Configure();
   \        0xE   0x.... 0x....      BL       EXTI_Configure
    376          
    377              USART1_Init();
   \       0x12   0x.... 0x....      BL       USART1_Init
    378          
    379              NVIC_Configure();
   \       0x16   0x.... 0x....      BL       NVIC_Configure
    380              go_advan();
   \       0x1A   0x.... 0x....      BL       go_advan
   \       0x1E   0xE00E             B.N      ??main_0
    381              
    382              while (1) {
    383                  if(advan_back) {
    384                      onLed(flag);
    385                      flag = (flag+1)%4;
    386                  }
    387                  else{
    388                      onLed(flag);
    389                      if(flag==0) flag=3;
    390                      else flag--;
   \                     ??main_1: (+1)
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0x6020             STR      R0,[R4, #+0]
   \       0x26   0xE008             B.N      ??main_2
   \                     ??main_3: (+1)
   \       0x28   0x....             LDR.N    R4,??DataTable11_7
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x.... 0x....      BL       onLed
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD1F4             BNE.N    ??main_1
   \       0x36   0x2003             MOVS     R0,#+3
   \       0x38   0x6020             STR      R0,[R4, #+0]
    391                  }
    392          
    393                 Delay();
   \                     ??main_2: (+1)
   \       0x3A   0x.... 0x....      BL       Delay
   \                     ??main_0: (+1)
   \       0x3E   0x....             LDR.N    R0,??DataTable11_6
   \       0x40   0x7800             LDRB     R0,[R0, #+0]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD0F0             BEQ.N    ??main_3
   \       0x46   0x....             LDR.N    R4,??DataTable11_7
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x.... 0x....      BL       onLed
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x1C40             ADDS     R0,R0,#+1
   \       0x52   0x2104             MOVS     R1,#+4
   \       0x54   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x58   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x5C   0x6020             STR      R0,[R4, #+0]
   \       0x5E   0xE7EC             B.N      ??main_2
    394              }
    395              return 0;
                     ^
Warning[Pe111]: statement is unreachable
    396          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x4001'0C00        DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x4001'1400        DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x4001'0800        DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0x4001'3800        DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x....'....        DC32     advan_back

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x....'....        DC32     flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \        0x0   0x000F'4240        DC32     0xf4240

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Delay
      24   EXTI15_10_IRQHandler
        24   -> EXTI_ClearITPendingBit
        24   -> EXTI_GetITStatus
        24   -> GPIO_ReadInputDataBit
        24   -> sendDataUART1
       8   EXTI4_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
      16   EXTI_Configure
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
      16   GPIO_Configure
        16   -> GPIO_Init
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCC_Configure
         8   -> RCC_APB2PeriphClockCmd
      16   USART1_IRQHandler
        16   -> USART_ClearITPendingBit
        16   -> USART_GetITStatus
        16   -> USART_ReceiveData
        16   -> onLed
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   __NVIC_EnableIRQ
      16   go_advan
        16   -> Delay
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
      16   go_back
        16   -> Delay
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
       8   main
         8   -> Delay
         8   -> EXTI_Configure
         8   -> GPIO_Configure
         8   -> NVIC_Configure
         8   -> RCC_Configure
         8   -> SystemInit
         8   -> USART1_Init
         8   -> go_advan
         8   -> onLed
      16   onLed
        16   -> Delay
        16   -> GPIO_ResetBits
        16   -> GPIO_SetBits
       8   sendDataUART1
         8   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      12  ?_0
      14  Delay
     112  EXTI15_10_IRQHandler
      38  EXTI4_IRQHandler
     116  EXTI_Configure
     136  GPIO_Configure
     120  NVIC_Configure
      54  RCC_Configure
      80  USART1_IRQHandler
      72  USART1_Init
      30  __NVIC_EnableIRQ
       1  advan_back
       4  flag
     230  go_advan
     236  go_back
      96  main
     110  onLed
      22  sendDataUART1

 
     4 bytes in section .bss
     1 byte  in section .data
    12 bytes in section .rodata
 1'506 bytes in section .text
 
 1'506 bytes of CODE  memory
    12 bytes of CONST memory
     5 bytes of DATA  memory

Errors: none
Warnings: 1
